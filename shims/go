#!/usr/bin/env bash

set -euo pipefail

# This script wraps golang and runs `asdf reshim` after install and get commands.
# Any other cases are passed-through to golang.
#
# To skip reshimming, set the environment variable `ASDF_GOLANG_SKIP_RESHIM=1`.
# To set go path, use the environment variable `ASDF_GOLANG_CANON_GO_PATH`.
#
# Inspired by asdf-nodejs: https://github.com/asdf-vm/asdf-nodejs/blob/b2d06a768d9a14186db72018df10604bdb384436/shims/npm

should_reshim() {
  # Skip reshim if ASDF_GOLANG_SKIP_RESHIM is set
  [[ "${ASDF_GOLANG_SKIP_RESHIM:-}" == "1" ]] && return 1

  # Handle install command
  local subcmd="${1-}"
  [[ "$subcmd" == "install" ]] && return 0

  return 1
}

determine_plugin_name() {
  local self="${1:-}"
  local plugin_name=""

  if command -v asdf >/dev/null 2>&1; then
    # List available plugins
    plugin_name=$(asdf plugin-list | grep -o '[a-zA-Z0-9_-]*' | grep -i golang 2>/dev/null | head -n1)
  fi

  if [[ -z "$plugin_name" ]]; then
    # Extract from directory structure
    local script_dir
    script_dir="$(cd "$(dirname "$self")" && pwd)"
    local plugin_dir
    plugin_dir="$(cd "$script_dir/.." && pwd)"
    plugin_name="$(basename "$plugin_dir")"
  fi

  echo "$plugin_name"
}

resolve_canon_go() {
  local self="${BASH_SOURCE[0]:-$0}"

  # User provided
  if [[ -n "${ASDF_GOLANG_CANON_GO_PATH:-}" ]]; then
    local p="$ASDF_GOLANG_CANON_GO_PATH"
    if [[ -x "$p" && "$p" != "$self" && "$p" != *"/shims/go" ]]; then
      echo "$p"
      return
    fi
  fi

  # Resolve using asdf
  if command -v asdf >/dev/null 2>&1; then
    local p
    p=$(asdf which go 2>/dev/null || true)
    if [[ -n "$p" && -x "$p" && "$p" != "$self" ]]; then
      echo "$p"
      return
    fi
  fi

  # Determine the plugin name dynamically
  local plugin_name
  plugin_name=$(determine_plugin_name "$self")

  # Resolve based on current version
  local current_version
  current_version=$(asdf current "$plugin_name" 2>/dev/null | awk '{print $2}' | head -n1)
  if [[ -n "$current_version" ]]; then
    local asdf_data_dir="${ASDF_DATA_DIR:-$HOME/.asdf}"
    local asdf_go_path="$asdf_data_dir/installs/$plugin_name/$current_version/go/bin/go"
    if [[ -x "$asdf_go_path" ]]; then
      echo "$asdf_go_path"
      return
    fi
  fi

  # Fallback to PATH, but avoid recursion
  local go_path
  go_path=$(command -v go 2>/dev/null || true)
  if [[ -n "$go_path" && -x "$go_path" && "$go_path" != "$self" && "$go_path" != *"/shims/go" ]]; then
    echo "$go_path"
    return
  fi

  # Better error message with helpful instructions
  echo "No version of $plugin_name set. Please run one of the following:" >&2
  echo "  asdf global $plugin_name <version>" >&2
  echo "  asdf local $plugin_name <version>" >&2
  echo "  asdf install $plugin_name <version>" >&2
  echo "See 'asdf list all $plugin_name' for available versions." >&2
  exit 127
}

wrap_go_and_reshim() {
  local canon_go_path
  canon_go_path=$(resolve_canon_go)

  if ! should_reshim "$@"; then
    # No reshim needed, execute directly
    exec "$canon_go_path" "$@"
  fi

  # Run original command (reshim needed)
  "$canon_go_path" "$@"
  local exit_code=$?

  # Only reshim if the command succeeded and asdf is available
  if [[ $exit_code -eq 0 ]] && command -v asdf >/dev/null 2>&1; then
    echo "Reshimming asdf golang..." >&2
    asdf reshim golang || echo "Warning: asdf reshim failed." >&2
  fi

  return $exit_code
}

# Call the wrapper function
wrap_go_and_reshim "$@"
